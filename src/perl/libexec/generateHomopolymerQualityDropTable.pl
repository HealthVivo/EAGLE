#!/usr/bin/env perl

=head1 LICENSE

Copyright (c) 2014 Illumina, Inc.

This file is part of Illumina's Enhanced Artificial Genome Engine (EAGLE),
covered by the "BSD 2-Clause License" (see accompanying LICENSE file)

=head1 NAME

generateHomopolymerQualityDropTable.pl

=head1 DIAGNOSTICS

=head2 Exit status

0: successful completion
1: abnormal completion
2: fatal error

=head2 Errors

All error messages are prefixed with "ERROR: ".

=head2 Warnings

All warning messages generated by EAGLE are prefixed with "WARNING: ".

=head1 SYNOPSIS

After running this tool, the final table can be generated using:

for b1 in 0 1 2 3; do
  for b2 in 0 1 2 3; do
    ( echo "id ${b1}_${b2}" ;
    for i in `seq 1 100`; do
      grep -P "^[0-9]* $i ${b1} ${b2}" ##FILE## |awk '{ref=$9+$12; ratio1=$9/ref*100 ; ratio2=$12/ref*100; if (0) {print ratio1 " " ratio2 " " $9 " " $12 " " ref " " $0 } sumRatio1+=ratio1; count+=1 } END { if (count) { print "'$i' "sumRatio1/count} }'
    ; done ) > out_${b1}_${b2}
  & done
& done

echo -n "cat out_0_0" ; 
for b1 in 0 1 2 3; do
  for b2 in 0 1 2 3; do
    echo -n " | join -a 1 -a 2 - out_${b1}_${b2}"
  ; done
; done ; echo " > out_all"


=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

All documented features are fully implemented.

Please report problems to Illumina Technical Support (support@illumina.com)

Patches are welcome.

=head1 AUTHOR

Lilian Janin

=cut

use warnings FATAL => 'all';
use strict;
use Cwd qw(abs_path);
use POSIX;
use IO::File;
use Carp;

use Pod::Usage;
use Getopt::Long;


my $VERSION = '@EAGLE_VERSION_FULL@';

my $programName = (File::Spec->splitpath(abs_path($0)))[2];
my $programPath = (File::Spec->splitpath(abs_path($0)))[1];
my $Version_text =
    "$programName $VERSION\n"
  . "Copyright (c) 2014 Illumina, Inc.\n";

my $usage =
    "Usage: $programName [options]\n"
  . "\t-l, --laneDir=PATH           - lane directory in Run Folder\n"
  . "\t-t, --tile=filename          - tile BCL file\n"
  . "\t-o, --output=PATH            - output quality table file\n"

  . "\t--help                       - prints usage guide\n"
  . "\t--version                    - prints version information\n"

.<<'EXAMPLES_END';

EXAMPLES:
    (none)

EXAMPLES_END

my $man             = 0;
my $help            = !(scalar @ARGV);
my $version         = 0;
my %PARAMS           = ();

my $argvStr = join ' ', @ARGV;

$PARAMS{verbose} = 0;

$PARAMS{laneDir} = "";
$PARAMS{tile} = "";
$PARAMS{output} = "";

my $result = GetOptions(
    "laneDir|l=s"           => \$PARAMS{laneDir},
    "tile|t=s"              => \$PARAMS{tile},
    "output|o=s"            => \$PARAMS{output},

    "version|V!"            => \$version,
    "help|h|?!"             => \$help,
    "man!"                  => \$man
)
  or pod2usage(2);

pod2usage(-exitstatus => 0, -verbose => 99, -sections => 'NAME|VERSION|DESCRIPTION|SYNOPSIS|ARGUMENTS|OPTIONS|NOTE') if $help;
pod2usage(-exitstatus => 0, -verbose => 99, -sections => 'NAME|VERSION')                                             if $version;
pod2usage(-exitstatus => 0, -verbose => 2,  -input => $1)  if ($man and $0 =~ /(.*)/);
pod2usage("$0: Too many positional arguments.\n")          if (1 < @ARGV);

# display the version info
if ($version) {
    print $Version_text;
    exit(0);
}

# display the help text when no output directory or other required options are given
if ( ( $result == 0 || !$PARAMS{laneDir} || !$PARAMS{output} ) && 'nohelp' eq $help) {
    die "$usage";
}

die("ERROR: Unrecognized command-line argument(s): @ARGV")  if (0 < @ARGV);


my $myInt32 = "";
my $myInt8 = "";


# Check that we won't overwrite any existing file
(! -e "$PARAMS{output}") or die "$PARAMS{output} already exist in the curent directory. Aborting.";

# Count how many cycles are available
print STDERR "Counting cycles";
my $cycleCount = 1;
while (-e "$PARAMS{laneDir}/C${cycleCount}.1") {$cycleCount++; print STDERR "."; }
$cycleCount--;
print STDERR "\n";
print "Found ${cycleCount} cycles\n";
$cycleCount /= 2;
print "Using ${cycleCount} cycles\n";

my %stats;
my %statsNotPF;
my $lastPercent = 0;
my @qualitiesForRead;

my @averageQualityAtCycleKWithoutHomopolymer;
my @averageQualityAtCycleKAfterPolyXOfLengthN;

my @qualitySumAtCycleKAfterPolyXOfLengthN;
my @qualityCountAtCycleKAfterPolyXOfLengthN;

for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  for (my $base=0; $base<4; $base++) {
    $qualitySumAtCycleKAfterPolyXOfLengthN[$cycle][0][0][$base] = 0;
    $qualityCountAtCycleKAfterPolyXOfLengthN[$cycle][0][0][$base] = 0;
  }
}


my @tiles;
if ($PARAMS{tile}) {
  push( @tiles, $PARAMS{tile} );
}
else {
  @tiles = glob("$PARAMS{laneDir}/C1.1/*.bcl");
}

foreach my $tile (@tiles) {
$tile =~ s/.*(s.*).bcl/$1/g;
print "Processing tile $tile\n";

# Create array of BCL files
my @bclFiles;
my $readCount = -1;
push @bclFiles, 0; # fake value, as cycle 0 doesn't exist
for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  my $file;
  my $filename = "$PARAMS{laneDir}/C${cycle}.1/${tile}.bcl";
  open( $file, "<", "$filename" ) or die "Cannot open $filename";
  binmode $file;
  push @bclFiles, $file;

  if (read ($file, $myInt32, 4)) {
    my $a = unpack('L',$myInt32);
    if ($readCount == -1) {
      $readCount = $a;
    }
    elsif ($readCount != $a) {
      die "Wrong read count in $filename: $a != $readCount";
    }
  }
}
print "Number of reads=$readCount\n";

# Open filter file
my $filterFile;
my $filterFilename = "$PARAMS{laneDir}/${tile}.filter";
open( $filterFile, "<", "$filterFilename" ) or die "Cannot open $filterFilename";
binmode $filterFile;
read ($filterFile, $myInt32, 4) or die "Problem reading filter file";
read ($filterFile, $myInt32, 4) or die "Problem reading filter file";
my $a = unpack('L',$myInt32);
($a == 3) or die "This tool only supports filter files version 3. This one is version $a";
read ($filterFile, $myInt32, 4) or die "Problem reading filter file";
$a = unpack('L',$myInt32);
if ($readCount != $a) {
  die "Wrong read count in filter file $filterFilename: $a != $readCount";
}


open OUTF, ">$PARAMS{output}" or die "Can't open $PARAMS{output} for writing";

for (my $readNum=0; $readNum<$readCount; $readNum++) {
#  my $lastQ = 0;
  my $qSum = 0;
  read ($filterFile, $myInt8, 1) or die "Error reading filter entry for read $readNum";
  my $PFvalue = unpack('C',$myInt8);
  my $homopolymerLength = 1;
  my $homopolymerBase = 1;
  my $firstHomopolymerBase = 0;
  my $firstHomopolymerLength = 0;
  my $lastBase = -1;
  my $ignoreNextBases = 0; #but still read them from file to update file cursor
  for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
    read ($bclFiles[$cycle], $myInt8, 1) or die "Error reading cycle $cycle";
    if ($ignoreNextBases) { next; }
    my $bclBase = unpack('C',$myInt8);
    my $qual = $bclBase >> 2;
    my $base = $bclBase & 3;
#    if ($homopolymerLength > 20 || $firstHomopolymerLength > 20) {
#      print "tile=$tile readNum=$readNum cycle=$cycle bclBase=$bclBase base=$base qual=$qual homopolymerLength=$homopolymerLength firstHomopolymerLength=$firstHomopolymerLength\n";
#    }
    if ($qual > 0 ) {
      if ($base == $lastBase) {
        $homopolymerLength++;
        $homopolymerBase = $base;
      }
      else {
        if ($homopolymerLength >= 5) {
          if ($firstHomopolymerLength == 0) {
            $firstHomopolymerBase = $homopolymerBase;
            $firstHomopolymerLength = $homopolymerLength;
          }
          else {
            $ignoreNextBases = 1;
          }
        }
        $homopolymerLength = 1;

        $qualitySumAtCycleKAfterPolyXOfLengthN[$cycle][$firstHomopolymerBase][$firstHomopolymerLength][$base] += $qual;
        $qualityCountAtCycleKAfterPolyXOfLengthN[$cycle][$firstHomopolymerBase][$firstHomopolymerLength][$base]++;
        $lastBase = $base;
#        if ($homopolymerLength > 20 || $firstHomopolymerLength > 20) {
#          print "cycle=$cycle, $firstHomopolymerBase, $firstHomopolymerLength += $qual\n";
#        }

        # as a first attempt, we only consider 1 base after each homopolymer
        if ($firstHomopolymerLength > 0) {
          $ignoreNextBases = 1;
        }
      }
    }
  }
}
}


for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  print OUTF "cycle:$cycle\n";
  my @refValues;
  for (my $base2=0; $base2<4; $base2++) {
    print OUTF "cycle:$cycle base2:$base2 ";
    my $sum = $qualitySumAtCycleKAfterPolyXOfLengthN[$cycle][0][0][$base2];
    my $count = $qualityCountAtCycleKAfterPolyXOfLengthN[$cycle][0][0][$base2];
    print OUTF " " . $sum;
    print OUTF " / " . $count;
    if ($count) {
      print OUTF " = " . $sum / $count . "\n";
      $refValues[$base2] = $sum / $count;
    }
    else {
      $refValues[$base2] = 0;
    }
  }
#    print OUTF " " . $qualitySumAtCycleKAfterPolyXOfLengthN[$cycle][$firstHomopolymerBase][$firstHomopolymerLength] . "\n";
  for (my $homopolymerLength=1; $homopolymerLength<50; $homopolymerLength++) {
    for (my $base=0; $base<4; $base++) {
      for (my $base2=0; $base2<4; $base2++) {
        if (defined $qualitySumAtCycleKAfterPolyXOfLengthN[$cycle][$base][$homopolymerLength][$base2]) {
          print OUTF "$cycle $homopolymerLength $base $base2: ";
          my $sum = $qualitySumAtCycleKAfterPolyXOfLengthN[$cycle][$base][$homopolymerLength][$base2];
          my $count = $qualityCountAtCycleKAfterPolyXOfLengthN[$cycle][$base][$homopolymerLength][$base2];
          print OUTF " " . $sum;
          print OUTF " / " . $count;
          print OUTF " = " . $sum / $count;
          print OUTF " = ref+ " . ($refValues[$base2] - $sum / $count) . "\n";
          #    print OUTF "cycle=$cycle\tlastQ=$lastQ\tnewQ=$qual\n";
          #    $lastQ = $qual;
        }
      }
    }
  }
}

exit(0);

# Print results
#print OUTF "# cycle\tlastQ\tnewQ\tcount\n";
#for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
#  if (defined $stats{$cycle}) {
#    for (my $i=0; $i<=40; $i++) {
#      if (defined $stats{$cycle}{$i}) {
#        for (my $j=0; $j<=40; $j++) {
#          if (defined $stats{$cycle}{$i}{$j}) {
#            print OUTF "$cycle\t$i\t$j\t" . $stats{$cycle}{$i}{$j} . "\n"
#          }
#        }
#      }
#    }
#  }
#}

close OUTF;


# Print results using format 2 (table)
open OUTF2, ">$PARAMS{output}.format2" or die "Can't open $PARAMS{output}.format2 for writing";
print OUTF2 "# cycle\tlastQ\tcount of newQ=0\tcount of newQ=1\t...\tcount of newQ=40\n";
for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  for (my $i=0; $i<=40; $i++) {
    print OUTF2 "$cycle\t$i";
    my $sum = 0;
    if (defined $stats{$cycle} && defined $stats{$cycle}{$i}) {
      for (my $j=0; $j<=40; $j++) {
        if (defined $stats{$cycle}{$i}{$j}) {
          $sum += $stats{$cycle}{$i}{$j};
        }
      }
    }
    if ($sum != 0) {
      for (my $j=0; $j<=40; $j++) {
        if (defined $stats{$cycle}{$i}{$j}) {
          print OUTF2 "\t" . $stats{$cycle}{$i}{$j};
        }
        else {
          print OUTF2 "\t0";
        }
      }
    }
    print OUTF2 "\n";
  }
}
close OUTF2;

# Print results using format 3 (normalised table)
open OUTF3, ">$PARAMS{output}.format3" or die "Can't open $PARAMS{output}.format3 for writing";
print OUTF3 "# cycle\tlastQ\tcount of newQ=0\tcount of newQ=1\t...\tcount of newQ=40\n";
for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  for (my $i=0; $i<=40; $i++) {
    print OUTF3 "$cycle\t$i";
    my $sum = 0;
    for (my $j=0; $j<=40; $j++) {
      if (defined $stats{$cycle} && defined $stats{$cycle}{$i} && defined $stats{$cycle}{$i}{$j}) {
        $sum += $stats{$cycle}{$i}{$j};
      }
    }
    for (my $j=0; $j<=40; $j++) {
      if (defined $stats{$cycle} && defined $stats{$cycle}{$i} && defined $stats{$cycle}{$i}{$j}) {
        print OUTF3 "\t" . ($stats{$cycle}{$i}{$j} / $sum);
      }
      else {
        print OUTF3 "\t0";
      }
    }
    print OUTF3 "\n";
  }
}
close OUTF3;

# Print results using format 2 (table) for not-PF reads
open OUTF2, ">$PARAMS{output}.notPF.format2" or die "Can't open $PARAMS{output}.notPF.format2 for writing";
print OUTF2 "# cycle\tlastQ\tcount of newQ=0\tcount of newQ=1\t...\tcount of newQ=40\n";
for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  for (my $i=0; $i<=40; $i++) {
    print OUTF2 "$cycle\t$i";
    for (my $j=0; $j<=40; $j++) {
      if (defined $statsNotPF{$cycle} && defined $statsNotPF{$cycle}{$i} && defined $statsNotPF{$cycle}{$i}{$j}) {
        print OUTF2 "\t" . $statsNotPF{$cycle}{$i}{$j};
      }
      else {
        print OUTF2 "\t0";
      }
    }
    print OUTF2 "\n";
  }
}
close OUTF2;

print "Done. If you wish to split a format2 table, use an awk script such as awk 'BEGIN { OFS=\"\\t\" } { if (\$1 > 101) { \$1-=101; print \$0 } }'\n";

