#!/usr/bin/env perl

=head1 LICENSE

Copyright (c) 2014 Illumina, Inc.

This file is part of Illumina's Enhanced Artificial Genome Engine (EAGLE),
covered by the "BSD 2-Clause License" (see accompanying LICENSE file)

=head1 NAME

scaleQualityTable.pl

=head1 DIAGNOSTICS

=head2 Exit status

0: successful completion
1: abnormal completion
2: fatal error

=head2 Errors

All error messages are prefixed with "ERROR: ".

=head2 Warnings

All warning messages generated by EAGLE are prefixed with "WARNING: ".

=head1 CONFIGURATION AND ENVIRONMENT

=back

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

All documented features are fully implemented.

Please report problems to Illumina Technical Support (support@illumina.com)

Patches are welcome.

=head1 AUTHOR

Lilian Janin

=cut

use warnings FATAL => 'all';
use strict;
use Cwd qw(abs_path);
use POSIX qw(strftime floor ceil);
use File::Spec;
use IO::File;
use Carp;
use List::Util qw(max);

use Pod::Usage;
use Getopt::Long;
use Data::Dumper;


my $VERSION = '@EAGLE_VERSION_FULL@';
my $DEBUG   = '@EAGLE_DEBUG_MODE@';

my $programName = (File::Spec->splitpath(abs_path($0)))[2];
my $programPath = (File::Spec->splitpath(abs_path($0)))[1];
my $Version_text =
    "$programName $VERSION\n"
  . "Copyright (c) 2014 Illumina, Inc.\n";

my $usage =
    "Usage: $programName [options]\n"
  . "\t-i, --input=PATH             - [input] \tpath to the input quality table\n"
  . "\t-c, --cycles=                - [input] \tnumber of requested cycles\n"
  . "\t-o, --output=PATH            - [output]\tpath to the generated file\n"
  . "\t--help                       - prints usage guide\n"
  . "\t--version                    - prints version information\n"

.<<'EXAMPLES_END';

EXAMPLES:
    (none)

EXAMPLES_END


my $man             = 0;
my $help            = !(scalar @ARGV);
my $version         = 0;
my $inFile          = undef;
my $outFile         = undef;
my $requestedCycles = 0;

my %options = 
(
    'help'           => \$help,
    'input'          => \$inFile,
    'output'         => \$outFile,
    'cycles'         => \$requestedCycles,
    "version"        => \$version,
    'man'            => \$man
);

my $result = GetOptions(\%options, 
                        'help|?', 'input|i=s', 'output|o=s', 'cycles|c=i', 'version|V', 'man')
             or pod2usage(2);

pod2usage(-verbose => 2,  -input => $1) if ($man and $0 =~ /(.*)/);

# display the version info
if ($version) {
    print $Version_text;
    exit(0);
}
# display the help screen
if ($help) {
    print $usage;
    exit(0);
}

if (!defined $inFile)
{
    croak "ERROR: *** missing option: --input ***\n       Type \"$programName --help\" for usage.\n";
}
if (!defined $outFile)
{
    croak "ERROR: *** missing option: --output ***\n       Type \"$programName --help\" for usage.\n";
}
if (!defined $requestedCycles)
{
    croak "ERROR: *** missing option: --cycles ***\n       Type \"$programName --help\" for usage.\n";
}
die("ERROR: Unrecognized command-line argument(s): @ARGV")  if (0 < @ARGV);

my %inputs = ();
my @qLevelsDef = ();
open INF,"<$inFile"  or croak "ERROR: *** failed to open '$inFile' ***\n";
open OUTF,">$outFile"  or croak "ERROR: *** failed to open '$outFile' for writing ***\n";
my $maxInputCycle = 0;
my $columnCount = 0;
while( <INF> ) {
    my $line = $_;
    chomp;
    if ( $_ =~ /^#/ ) { print OUTF $line; next; }
    if ( $_ =~ /^$/ ) { print OUTF $line; next; }
    my @values = split('\t');
    (@values > 40) or croak "ERROR: ${inFile}:$.: *** Expecting more than 40 tab-separated values ***\n";
    if ($values[1] == 0) {
        @qLevelsDef = @values;
        print OUTF $line;
        next;
    }

    # sanity check
    if ($columnCount) {
      ($columnCount == @values) or croak "ERROR: All lines must have the same number of columns (expecting $columnCount columns in \"$line\")";
    } else {
      $columnCount = @values;
    }

    push @{$inputs{$values[0]}{$values[1]}}, @values;
    $maxInputCycle = max( $maxInputCycle, $values[0] );
}
close INF;

print "max cycle: $maxInputCycle\n";

for (my $cycle=1; $cycle<=$requestedCycles; $cycle++) {

  my $cycleRatioPos = ($cycle-1)/($requestedCycles-1);
#  my $inputCycleFloatPos = 1+ $cycleRatioPos*($maxInputCycle-1);
  my $inputCycleFloatPos = 1+ (($maxInputCycle-1)*($cycle-1))/($requestedCycles-1);
  my $inputCycleBefore = floor($inputCycleFloatPos);
  my $inputCycleAfter = ceil($inputCycleFloatPos); # We use ceil instead of floor+1 to avoid going over the end of the input array
  my $weightInputCycleBefore = 1 - ( $inputCycleFloatPos - $inputCycleBefore );
  my $weightInputCycleAfter  = 1 - $weightInputCycleBefore;
  print "Cycle=$cycle, cycleRatioPos=$cycleRatioPos, inputCycleFloatPos=$inputCycleFloatPos, inputCycleBefore=$inputCycleBefore($weightInputCycleBefore), inputCycleAfter=$inputCycleAfter($weightInputCycleAfter)\n";

  for (my $qLevel=1; $qLevel<=@qLevelsDef-3; $qLevel++) {
    if ($qLevelsDef[$qLevel+2] != 0) {
      print OUTF "$cycle\t$qLevel";
      for (my $q=0; $q<$columnCount-2; $q++) {
        my $valBefore = $inputs{$inputCycleBefore}{$qLevel}[$q+2];
        my $valAfter  = $inputs{$inputCycleAfter }{$qLevel}[$q+2];
        my $mixedVal = $valBefore * $weightInputCycleBefore + $valAfter * $weightInputCycleAfter;
        print OUTF "\t$mixedVal";
      }
      print OUTF "\n";
    }
  }
}


close OUTF;

