#!/usr/bin/env perl

=head1 LICENSE

Copyright (c) 2014 Illumina, Inc.

This file is part of Illumina's Enhanced Artificial Genome Engine (EAGLE),
covered by the "BSD 2-Clause License" (see accompanying LICENSE file)

=head1 NAME

mergeFragments.pl

=head1 DIAGNOSTICS

=head2 Exit status

0: successful completion
1: abnormal completion
2: fatal error

=head2 Errors

All error messages are prefixed with "ERROR: ".

=head2 Warnings

All warning messages generated by EAGLE are prefixed with "WARNING: ".

=head1 CONFIGURATION AND ENVIRONMENT

=back

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

All documented features are fully implemented.

Please report problems to Illumina Technical Support (support@illumina.com)

Patches are welcome.

=head1 AUTHOR

Lilian Janin

=cut

use warnings FATAL => 'all';
use strict;
use Cwd qw(abs_path);
use POSIX qw(strftime);
use IO::File;
use Carp;

use Pod::Usage;
use Getopt::Long;


my $VERSION = '@EAGLE_VERSION_FULL@';

my $programName = (File::Spec->splitpath(abs_path($0)))[2];
my $programPath = (File::Spec->splitpath(abs_path($0)))[1];
my $Version_text =
    "$programName $VERSION\n"
  . "Copyright (c) 2014 Illumina, Inc.\n";

my $usage =
    "Usage: $programName [options]\n"
  . "\t-i, --dataset1=PATH          - 1st dataset directory\n"
  . "\t-j, --dataset2=PATH          - 2nd dataset directory\n"

  . "\t--help                       - prints usage guide\n"
  . "\t--version                    - prints version information\n"

.<<'EXAMPLES_END';

EXAMPLES:
    (none)

EXAMPLES_END

my $help             = 'nohelp';
my $isVersion        = 0;
my %PARAMS           = ();

my $argvStr = join ' ', @ARGV;

$PARAMS{verbose} = 0;

$PARAMS{dataset1} = "";
$PARAMS{dataset2} = "";

my $result = GetOptions(
    "dataset1|i=s"          => \$PARAMS{dataset1},
    "dataset2|j=s"          => \$PARAMS{dataset2},

    "version"               => \$isVersion,
    "help"                  => \$help
);

# display the version info
if ($isVersion) {
    print $Version_text;
    exit(0);
}

# display the help text when no output directory or other required options are given
if ( ( $result == 0 || !$PARAMS{dataset1} || !$PARAMS{dataset2} ) && 'nohelp' eq $help) {
    die "$usage";
}

die("ERROR: Unrecognized command-line argument(s): @ARGV")  if (0 < @ARGV);


# Check that we won't overwrite any existing file
(! -e "fragments/fragments.length") or die "fragments.* already exist in the current directory. Aborting.";
system( "mkdir -p fragments" );

# Merging fragments.length : simple concatenation
system( "cat $PARAMS{dataset1}/fragments/fragments.length $PARAMS{dataset2}/fragments/fragments.length > fragments/fragments.length" );

# Merging fragments.tile : simple concatenation
system( "cat $PARAMS{dataset1}/fragments/fragments.tile $PARAMS{dataset2}/fragments/fragments.tile > fragments/fragments.tile" );

# Merging fragments.stats : sum of each int32
my $myInt32_1 = "";
my $myInt32_2 = "";
open INF1, "<$PARAMS{dataset1}/fragments/fragments.stats" or die "Can't open $PARAMS{dataset1}/fragments/fragments.stats";
open INF2, "<$PARAMS{dataset2}/fragments/fragments.stats" or die "Can't open $PARAMS{dataset2}/fragments/fragments.stats";
open OUTF, ">fragments/fragments.stats" or die "Can't open fragments/fragments.stats for writing";
binmode INF1;
binmode INF2;
binmode OUTF;
my $dataAvailable = 1;
while ($dataAvailable)
  {
    my $a = 0;
    my $b = 0;
    $dataAvailable = 0;
    if (read (INF1, $myInt32_1, 4)) {
      $a = unpack('L',$myInt32_1);
      $dataAvailable = 1;
    }
    if (read (INF2, $myInt32_2, 4)) {
      $b = unpack('L',$myInt32_2);
      $dataAvailable = 1;
    }
    if ($dataAvailable)
      {
        $a += $b;
        print OUTF pack('L',$a);
      }
  }
close INF1;
close INF2;
close OUTF;

# Merging fragments.pos : concatenation with adjustment of first value of second dataset
my $finalPosInDataset1 = 0;
open INF1, "<$PARAMS{dataset1}/fragments/fragments.pos" or die "Can't open $PARAMS{dataset1}/fragments/fragments.pos";
binmode INF1;
my $myInt16;
while (read (INF1, $myInt16, 2))
  {
    my $offset = unpack('S',$myInt16);
    #    print "offset=$offset\n";
    $finalPosInDataset1 += $offset;
  }
close INF1;
print "finalPosInDataset1 = $finalPosInDataset1 \n";
my $dataset1Length = `grep totalBases $PARAMS{dataset1}/sample_genome/genome_size.xml |sed 's/.*totalBases="*//' | cut -d '"' -f 1 | awk 'BEGIN { sum=0 } { sum+=\$1 } END { print sum }'`;
print "Length of dataset 1: $dataset1Length\n";
system( "cp $PARAMS{dataset1}/fragments/fragments.pos fragments/fragments.pos" );
open OUTF, ">>fragments/fragments.pos" or die "Can't open fragments/fragments.pos";
binmode OUTF;
my $offset = $dataset1Length - $finalPosInDataset1;

open INF1, "<$PARAMS{dataset2}/fragments/fragments.pos" or die "Can't open $PARAMS{dataset2}/fragments/fragments.pos";
binmode INF1;
read (INF1, $myInt16, 2);
$offset += unpack('S',$myInt16);
print "New offset=$offset\n";
close INF1;
if ($offset < 65535) {
  print OUTF pack('s',$offset);
}
else {
  ($offset < 65536*65536*65536) or die "Oh noooo, the jump between the 2 datasets is too large!";
  print OUTF pack( 's', 65535 );
  print OUTF pack( 's', $offset >> 32 );
  print OUTF pack( 's', ( $offset >> 16 ) & 0xFFFF );
  print OUTF pack( 's', $offset & 0xFFFF );
}

system( "tail -c +3 $PARAMS{dataset2}/fragments/fragments.pos >> fragments/fragments.pos" );

system( "touch fragments/fragments.done" );

print "Fragments successfully merged\n";
