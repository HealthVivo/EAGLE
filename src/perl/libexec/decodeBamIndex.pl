#!/usr/bin/env perl

=head1 LICENSE

Copyright (c) 2014 Illumina, Inc.

This file is part of Illumina's Enhanced Artificial Genome Engine (EAGLE),
covered by the "BSD 2-Clause License" (see accompanying LICENSE file)

=head1 NAME

mergeFragments.pl

=head1 DIAGNOSTICS

=head2 Exit status

0: successful completion
1: abnormal completion
2: fatal error

=head2 Errors

All error messages are prefixed with "ERROR: ".

=head2 Warnings

All warning messages generated by EAGLE are prefixed with "WARNING: ".

=head1 CONFIGURATION AND ENVIRONMENT

=back

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

All documented features are fully implemented.

Please report problems to Illumina Technical Support (support@illumina.com)

Patches are welcome.

=head1 AUTHOR

Lilian Janin

=cut

use warnings FATAL => 'all';
use strict;
use Cwd qw(abs_path);
use POSIX qw(strftime);
use IO::File;
use Carp;

use Pod::Usage;
use Getopt::Long;


my $VERSION = '@EAGLE_VERSION_FULL@';

my $programName = (File::Spec->splitpath(abs_path($0)))[2];
my $programPath = (File::Spec->splitpath(abs_path($0)))[1];
my $Version_text =
    "$programName $VERSION\n"
  . "Copyright (c) 2014 Illumina, Inc.\n";

my $usage =
    "Usage: $programName [options]\n"
  . "\t-i, --input=PATH          - 1st input directory\n"

  . "\t--help                       - prints usage guide\n"
  . "\t--version                    - prints version information\n"

.<<'EXAMPLES_END';

EXAMPLES:
    (none)

EXAMPLES_END



my $help = 'nohelp';

my $isVersion = 0;
my %PARAMS = ();

my $argvStr = join ' ', @ARGV;

$PARAMS{verbose} = 0;

$PARAMS{input} = "";

my $result = GetOptions(
    "input|i=s"          => \$PARAMS{input},

    "version"               => \$isVersion,
    "help"                  => \$help
);

# display the version info
if ($isVersion)
{
    print $Version_text;
    exit (0);
}
# display the help text when no output directory or other required options are given
if (($result == 0 || !$PARAMS{input} ) && 'nohelp' eq $help)
{
    die "$usage";
}

die ("ERROR: Unrecognized command-line argument(s): @ARGV") if (0 < @ARGV);

# Merging fragments.stats : sum of each int32
my $myInt32_1 = "";
my $myInt64 = "";
open INF1, "<$PARAMS{input}" or die "Can't open $PARAMS{input}";
binmode INF1;

if (read (INF1, $myInt32_1, 4))
{
    $a = unpack ('L', $myInt32_1);
    print "magic: $a (should be 21578050)\n";
}

my $nRef = 0;
if (read (INF1, $myInt32_1, 4))
{
    $nRef = unpack ('L', $myInt32_1);
    print "n_ref: $nRef\n";
}

for (my $ref = 0; $ref < $nRef; $ref++)
{
  print " *ref=$ref\n";

    my $nBin = 0;
    if (read (INF1, $myInt32_1, 4))
    {
        $nBin = unpack ('L', $myInt32_1);
        print " n_bin: $nBin\n";
    }

    for (my $bin = 0; $bin < $nBin; $bin++)
    {
  print "  *bin=$bin\n";

        my $binNum;
        if (read (INF1, $myInt32_1, 4))
        {
            $binNum = unpack ('L', $myInt32_1);
            print "  binNum: $binNum\n";
        }

  if ($binNum != 37450)
      {
        my $nChunk = 0;
        if (read (INF1, $myInt32_1, 4))
        {
            $nChunk = unpack ('L', $myInt32_1);
            print "  n_chunk: $nChunk\n";
        }

        for (my $chunk = 0; $chunk < $nChunk; $chunk++)
        {
  print "   *chunk=$chunk\n";

            print "   chunk_beg: ";
            # Read&print Virtual offset
            if (read (INF1, $myInt64, 8))
            {
              my $q = unpack ('Q', $myInt64);
              my $coffset = $q >> 16;
              my $uoffset = $q & 0xFFFF;
                print "{c=$coffset, u=$uoffset}"
            }
            print "\n";

            print "   chunk_end: ";
            # Read&print Virtual offset
            if (read (INF1, $myInt64, 8))
            {
              my $q = unpack ('Q', $myInt64);
              my $coffset = $q >> 16;
              my $uoffset = $q & 0xFFFF;
                print "{c=$coffset, u=$uoffset}"
            }
            print "\n";
        }
      }
      else
      {
        print "  bin 37450 is samtools special bin\n";
        if (read (INF1, $myInt32_1, 4))
        {
            my $nChunk = unpack ('L', $myInt32_1);
            print "  n_chunk: $nChunk (should be 2)\n";
            ($nChunk == 2) or die "2 chunks are expected in this special bin";
        }

            print "   off_beg: ";
            # Read&print Virtual offset
            if (read (INF1, $myInt64, 8))
            {
              my $q = unpack ('Q', $myInt64);
              my $coffset = $q >> 16;
              my $uoffset = $q & 0xFFFF;
                print "{c=$coffset, u=$uoffset}"
            }
            print "\n";

            print "   off_end: ";
            # Read&print Virtual offset
            if (read (INF1, $myInt64, 8))
            {
              my $q = unpack ('Q', $myInt64);
              my $coffset = $q >> 16;
              my $uoffset = $q & 0xFFFF;
                print "{c=$coffset, u=$uoffset}"
            }
            print "\n";

            if (read (INF1, $myInt64, 8))
            {
              my $q = unpack ('Q', $myInt64);
              print "   #aligned reads: $q\n";
            }

            if (read (INF1, $myInt64, 8))
            {
              my $q = unpack ('Q', $myInt64);
              print "   #unaligned reads: $q\n";
            }
      }
    }

    my $nIntv = 0;
    if (read (INF1, $myInt32_1, 4))
    {
        $nIntv = unpack ('L', $myInt32_1);
        print " n_intv: $nIntv\n";
    }

    for (my $intv = 0; $intv < $nIntv; $intv++)
    {
      print " *intv=$intv\n";

            print "  ioffset: ";
            # Read&print Virtual offset
            if (read (INF1, $myInt64, 8))
            {
              my $q = unpack ('Q', $myInt64);
              my $coffset = $q >> 16;
              my $uoffset = $q & 0xFFFF;
                print "{c=$coffset, u=$uoffset}"
            }
            print "\n";
    }

}

while (read (INF1, $myInt32_1, 4))
{
  my $extra = unpack ('L', $myInt32_1);
  print "!!!extra data at end of file: $extra\n";
}
