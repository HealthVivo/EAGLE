#!/usr/bin/env perl

=head1 LICENSE

Copyright (c) 2014 Illumina, Inc.

This file is part of Illumina's Enhanced Artificial Genome Engine (EAGLE),
covered by the "BSD 2-Clause License" (see accompanying LICENSE file)

=head1 NAME

generateQualityTable.pl

=head1 DIAGNOSTICS

=head2 Exit status

0: successful completion
1: abnormal completion
2: fatal error

=head2 Errors

All error messages are prefixed with "ERROR: ".

=head2 Warnings

All warning messages generated by EAGLE are prefixed with "WARNING: ".

=head1 CONFIGURATION AND ENVIRONMENT

=back

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

All documented features are fully implemented.

Please report problems to Illumina Technical Support (support@illumina.com)

Patches are welcome.

=head1 AUTHOR

Lilian Janin

=cut

use warnings FATAL => 'all';
use strict;
use diagnostics;
use Cwd qw(abs_path);
use POSIX;
use IO::File;
use Carp;

use Pod::Usage;
use Getopt::Long;


my $VERSION = '@EAGLE_VERSION_FULL@';

my $programName = (File::Spec->splitpath(abs_path($0)))[2];
my $programPath = (File::Spec->splitpath(abs_path($0)))[1];
my $Version_text =
    "$programName $VERSION\n"
  . "Copyright (c) 2014 Illumina, Inc.\n";

my $usage =
    "Usage: $programName [options]\n"
  . "\t-l, --laneDir=PATH           - lane directory in Run Folder\n"
  . "\t-t, --tile=filename          - tile BCL file\n"
  . "\t-o, --output=PATH            - output quality table file\n"
  . "\t-i, --ignore-reads-with-homopolymers-longer-than=INT - as it says\n"

  . "\t--help                       - prints usage guide\n"
  . "\t--version                    - prints version information\n"

.<<'EXAMPLES_END';

EXAMPLES:
    (none)

EXAMPLES_END

my $help             = 'nohelp';
my $isVersion        = 0;
my %PARAMS           = ();

my $argvStr = join ' ', @ARGV;

$PARAMS{verbose} = 0;

$PARAMS{laneDir} = "";
$PARAMS{tile} = "";
$PARAMS{output} = "";
my $ignoreReadsWithHomopolymersLongerThan = 0;

my $result = GetOptions(
    "laneDir|l=s"           => \$PARAMS{laneDir},
    "tile|t=s"              => \$PARAMS{tile},
    "output|o=s"            => \$PARAMS{output},
    "ignore-reads-with-homopolymers-longer-than|i=i" => \$ignoreReadsWithHomopolymersLongerThan,

    "version"               => \$isVersion,
    "help"                  => \$help
);

# display the version info
if ($isVersion) {
    print $Version_text;
    exit(0);
}

# display the help text when no output directory or other required options are given
if ( ( $result == 0 || !$PARAMS{laneDir} || !$PARAMS{tile} || !$PARAMS{output} ) && 'nohelp' eq $help) {
    die "$usage";
}

die("ERROR: Unrecognized command-line argument(s): @ARGV")  if (0 < @ARGV);


sub max ($$) { $_[$_[0] < $_[1]] }

my $myInt32 = "";
my $myInt8 = "";


# Check that we won't overwrite any existing file
(! -e "$PARAMS{output}") or die "$PARAMS{output} already exist in the curent directory. Aborting.";

# Count how many cycles are available
print STDERR "Counting cycles";
my $cycleCount = 1;
while (-e "$PARAMS{laneDir}/C${cycleCount}.1/$PARAMS{tile}.bcl" || -e "$PARAMS{laneDir}/C${cycleCount}.1/$PARAMS{tile}.bcl.gz") {$cycleCount++; print STDERR "."; }
$cycleCount--;
print STDERR "\n";
print "Found ${cycleCount} cycles\n";
$cycleCount /= 2;
$cycleCount --;
print "Processing read 1 only: ${cycleCount} cycles\n";

my @averageQualityPerCycle = ( 
                              33, 33, 33, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 40, 40, 40, 40, 40, 40, 40,
                              40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
                              40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
                              40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
                              40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
                              40, 40, 40, 40, 40, 40, 40, 40, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
                              37, 37, 37, 37, 37, 33, 33, 33, 33, 33,
                              33, 33, 33, 33, 33, 33, 33, 33, 33, 33,
                              33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33 );

#my @Qbins = ( 40, 37, 33, 27, 22, 15, 6, 2? );
my @Qbins = ( 
             0, 1, 1, 1, 2, 2, 2, 2, 2, 2,
             3, 3, 3, 3, 3, 3, 3, 3, 3, 4,
             4, 4, 4, 4, 4, 5, 5, 5, 5, 5,
             5, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8 );


# Create array of BCL files
my @bclFiles;
my $readCount = -1;
{
push @bclFiles, 0; # fake value, as cycle 0 doesn't exist
for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  my $file;
  my $filename = "$PARAMS{laneDir}/C${cycle}.1/$PARAMS{tile}.bcl";
  if (!open( $file, "<", "$filename" )) {
    open( $file, "gunzip -c $filename.gz |" )
      or die "Cannot open $filename";
  }
  binmode $file;
  push @bclFiles, $file;

  if (read ($file, $myInt32, 4)) {
    my $a = unpack('L',$myInt32);
    if ($readCount == -1) {
      $readCount = $a;
    }
    elsif ($readCount != $a) {
      die "Wrong read count in $filename: $a != $readCount";
    }
  }
}
}
print "Number of reads=$readCount\n";

# Open filter file
my $filterFile;
my $filterFilename = "$PARAMS{laneDir}/$PARAMS{tile}.filter";
open( $filterFile, "<", "$filterFilename" ) or die "Cannot open $filterFilename";
binmode $filterFile;
read ($filterFile, $myInt32, 4) or die "Problem reading filter file";
read ($filterFile, $myInt32, 4) or die "Problem reading filter file";
my $a = unpack('L',$myInt32);
($a == 3) or die "This tool only supports filter files version 3. This one is version $a";
read ($filterFile, $myInt32, 4) or die "Problem reading filter file";
$a = unpack('L',$myInt32);
if ($readCount != $a) {
  die "Wrong read count in filter file $filterFilename: $a != $readCount";
}


open OUTF, ">$PARAMS{output}" or die "Can't open $PARAMS{output} for writing";
open SSEFILE, ">$PARAMS{output}.sse" or die "Can't open $PARAMS{output}.sse for writing";


my %stats;
my %statsNotPF;
my $lastPercent = 0;
my @qualitiesForRead;

loopOverReads: for (my $readNum=0; $readNum<$readCount; $readNum++) {
  #  my $lastQ = 0;
  my $qSum = 0;
  read ($filterFile, $myInt8, 1) or die "Error reading filter entry for read $readNum";
  my $PFvalue = unpack('C',$myInt8);
  my $previousBase = -1;
  my $homopolymerLength = 0;
  my @bases = ();
  my @quals = ();
  my $hasN = 0;

  for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
    read ($bclFiles[$cycle], $myInt8, 1) or die "Error reading cycle $cycle";
    my $bclBase = unpack('C',$myInt8);
    my $base = $bclBase & 3;
    my $qual = $bclBase >> 2;

    push( @bases, $base );
    push( @quals, $qual );
    if ($bclBase == 0) { $hasN = 1; }

    $qualitiesForRead[$cycle] = $qual;
    $qSum += $qual;
  }
  my $averageQ = floor( $qSum/$cycleCount + 0.5 );
  if ($PFvalue == 1) {
    $stats{1}{0}{$averageQ}++;

    if (!$hasN) {

      my $glitchCount = 0;
      my @qualBins = @Qbins[ @quals ];
      my @qualBinSteps = map { $qualBins[$_] - $qualBins[$_-1] } 1 .. $#qualBins;
      my @glitchInfo = map( 0, @qualBins);

      # Just to make it easier later
      push( @qualBins, 0 );
      push( @qualBinSteps, 0 );
      push( @glitchInfo, 0 );

      for (my $cycle=1; $cycle<=$cycleCount-1; $cycle++) {

        # glitch detection
        if ($qualBinSteps[$cycle-1] < -2
            #         && (!defined $qualBinSteps[$cycle-2] < -2
            #             || $qualBinSteps[$cycle-2] >= 0
            #            )
           ) {
          # maybe a new glitch
          my $glitchHeight = -$qualBinSteps[$cycle-1];
          my $recoveredHeight = 0;
          my $glitchLength = 0;
          # Glitch half life calculation
          while ($recoveredHeight < $glitchHeight/2 && defined $qualBinSteps[$cycle-1+$glitchLength+1] && $qualBinSteps[$cycle-1+$glitchLength+1] >= 0) {
            $glitchLength++;
            $recoveredHeight += $qualBinSteps[$cycle - 1 + $glitchLength];
          }
          my $glitchHalfLife = $glitchLength;
          # Glitch almost full recovery
          while ($recoveredHeight < $glitchHeight-1 && defined $qualBinSteps[$cycle-1+$glitchLength+1] && $qualBinSteps[$cycle-1+$glitchLength+1] >= 0) {
            $glitchLength++;
            $recoveredHeight += $qualBinSteps[$cycle - 1 + $glitchLength];
          }
          # Glitch full recovery
          if ($recoveredHeight < $glitchHeight && defined $qualBinSteps[$cycle-1+$glitchLength+1] && $qualBinSteps[$cycle-1+$glitchLength+1] > 0) {
            $glitchLength++;
            $recoveredHeight += $qualBinSteps[$cycle - 1 + $glitchLength];
          }

          if ($recoveredHeight >= $glitchHeight/2) {
            $glitchCount ++;
            $glitchInfo[$cycle-1] = -1;
            for (my $i=1; $i<=$glitchLength; $i++) {
              if ($i <= $glitchHalfLife) {
                $glitchInfo[$cycle - 1 + $i] = 1;
              } else {
                $glitchInfo[$cycle - 1 + $i] = 2;
              }
            }

            # Glitch print out
            for (my $i=$cycle-1; $i>=max(1,$cycle-32); $i--) {
              print SSEFILE $bases[$i-1];
            }
            print SSEFILE "\n";
          }
        }
      }

      for (my $cycle=6; $cycle<=$cycleCount-1; $cycle++) {
        my $filename = "$PARAMS{output}.sse.";
        for (my $i=$cycle-1; $i>=$cycle-5; $i--) {
          $filename .= $bases[$i-1];
        }
        open OUT_SSExxxxx, ">>$filename" or die "Can't open $filename for writing";
        print OUT_SSExxxxx $qualBins[$cycle-2] . "\t" . $qualBins[$cycle-1] . "\n";
        close OUT_SSExxxxx;
      }

      for (my $cycle=6; $cycle<=$cycleCount-1; $cycle++) {
        my $filename = "$PARAMS{output}.ssep.";
        for (my $i=$cycle; $i>=$cycle-5; $i--) {
          $filename .= $bases[$i-1];
        }
        open OUT_SSExxxxx, ">>$filename" or die "Can't open $filename for writing";
        print OUT_SSExxxxx $qualBins[$cycle-2] . "\t" . $qualBins[$cycle-1] . "\n";
        close OUT_SSExxxxx;
      }

      my $previousQual = 0;
      my $previousRelQual = 0;
      my $strBases = "";
      my $strQuals = "";
      my $strQualSteps = "";
      my $strRelQuals = "";
      my $strRelQualSteps = "";
      my $strQualBins = "";
      my $strQualBinSteps = "";
      my $strGlitchInfo = "";
      my $sumAbsQualBinSteps = 0;
      my $sumSqQualBinSteps = 0;
      my $maxAbsQualBinSteps = 0;
      for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
        my $base = $bases[$cycle-1];
        my $qual = $quals[$cycle-1];

        $strBases .= sprintf("%3d", $base) . ",";
        $strQuals .= sprintf("%3d", $qual ) . ",";
        my $qualStep = $qual - $previousQual;
        $strQualSteps .= sprintf("%3d", $qualStep) . ",";
        my $relQual = $qual - $averageQualityPerCycle[$cycle - 1];
        my $relQualStep = $relQual - $previousRelQual;
        $strRelQuals .= sprintf("%3d", $relQual ) . ",";
        $strRelQualSteps .= sprintf("%3d", $relQualStep ) . ",";
        $strQualBins .= sprintf("%3d", $qualBins[$cycle-1] ) . ",";
        $strQualBinSteps .= sprintf("%3d", $qualBinSteps[$cycle-1] ) . ",";
        $strGlitchInfo .= sprintf("%3d", $glitchInfo[$cycle-1] ) . ",";

        my $qualBinStep = $qualBinSteps[$cycle-1];
        if ($glitchInfo[$cycle-1] != 0) { $qualBinStep = 0; }
        $sumAbsQualBinSteps += abs ( $qualBinStep );
        $sumSqQualBinSteps += ( $qualBinStep * $qualBinStep );
        $maxAbsQualBinSteps = max ( $maxAbsQualBinSteps, abs($qualBinStep) );

        $previousQual = $qual;
        $previousRelQual = $relQual;
        if ($cycle % 42 == 0) {
          $strBases .= "\n";
          $strQuals .= "\n";
          $strQualSteps .= "\n";
          $strRelQuals .= "\n";
          $strRelQualSteps .= "\n";
          $strQualBins .= "\n";
          $strQualBinSteps .= "\n";
          $strGlitchInfo .= "\n";
        }
      }

      my $mean10Qual = 0;
      for (my $cycle=$cycleCount-9; $cycle<=$cycleCount; $cycle++) {
        $mean10Qual += $quals[$cycle-1];
      }
      $mean10Qual /= 10;
      $mean10Qual = int( $mean10Qual );

      my $filename = "$PARAMS{output}.${maxAbsQualBinSteps}.lastMean${mean10Qual}";
      open OUT, ">>$filename" or die "Can't open $filename for writing";
      print OUT "bases:\n${strBases}\n";
      print OUT "quals:\n${strQuals}\n";
      #print OUT "qualSteps:\n${strQualSteps}\n";
      print OUT "relQuals:\n${strRelQuals}\n";
      #print OUT "relQualSteps:\n${strRelQualSteps}\n";
      print OUT "qualBins:\n${strQualBins}\n";
      print OUT "qualBinSteps:\n${strQualBinSteps}\n";
      print OUT "glitchInfo:\n${strGlitchInfo}\n";
      print OUT "\nsumAbsQualBinSteps:\t$sumAbsQualBinSteps\n";
      print OUT "sumSqQualBinSteps:\t$sumSqQualBinSteps\n";
      print OUT "maxAbsQualBinSteps:\t$maxAbsQualBinSteps\n";
      print OUT "glitchCount:\t$glitchCount\n";
      print OUT "mean10Qual:\t$mean10Qual\n";
      #print OUT "Press ENTER to continue";
      #<STDIN>;
      close OUT;
    }
  }
  else {
    $statsNotPF{1}{0}{$averageQ}++;
  }
  for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
    my $qual = $qualitiesForRead[$cycle];
    if ($PFvalue == 1) {
#    print "cycle=$cycle\tlastQ=$lastQ\tnewQ=$qual\tqSum=$qSum\taverageQ=$averageQ\n";
      $stats{$cycle}{$averageQ}{$qual}++;
    }
    else {
      $statsNotPF{$cycle}{$averageQ}{$qual}++;
    }
#    print OUTF "cycle=$cycle\tlastQ=$lastQ\tnewQ=$qual\n";
#    $lastQ = $qual;
  }
  if ($lastPercent < int($readNum*1000/$readCount)/10) {
    $lastPercent = int($readNum*1000/$readCount)/10;
    print "${lastPercent}%\n";
  }
}

# Print results
{
print OUTF "# cycle\tlastQ\tnewQ\tcount\n";
for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  if (defined $stats{$cycle}) {
    for (my $i=0; $i<=40; $i++) {
      if (defined $stats{$cycle}{$i}) {
        for (my $j=0; $j<=40; $j++) {
          if (defined $stats{$cycle}{$i}{$j}) {
            print OUTF "$cycle\t$i\t$j\t" . $stats{$cycle}{$i}{$j} . "\n"
          }
        }
      }
    }
  }
}
}

close OUTF;
close SSEFILE;


# Print results using format 2 (table)
{
open OUTF2, ">$PARAMS{output}.format2" or die "Can't open $PARAMS{output}.format2 for writing";
print OUTF2 "# cycle\tlastQ\tcount of newQ=0\tcount of newQ=1\t...\tcount of newQ=40\n";
for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  for (my $i=0; $i<=40; $i++) {
    print OUTF2 "$cycle\t$i";
    my $sum = 0;
    if (defined $stats{$cycle} && defined $stats{$cycle}{$i}) {
      for (my $j=0; $j<=40; $j++) {
        if (defined $stats{$cycle}{$i}{$j}) {
          $sum += $stats{$cycle}{$i}{$j};
        }
      }
    }
    if ($sum != 0) {
      for (my $j=0; $j<=40; $j++) {
        if (defined $stats{$cycle}{$i}{$j}) {
          print OUTF2 "\t" . $stats{$cycle}{$i}{$j};
        }
        else {
          print OUTF2 "\t0";
        }
      }
    }
    print OUTF2 "\n";
  }
}
close OUTF2;
}

# Print results using format 3 (normalised table)
{
open OUTF3, ">$PARAMS{output}.format3" or die "Can't open $PARAMS{output}.format3 for writing";
print OUTF3 "# cycle\tlastQ\tcount of newQ=0\tcount of newQ=1\t...\tcount of newQ=40\n";
for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  for (my $i=0; $i<=40; $i++) {
    print OUTF3 "$cycle\t$i";
    my $sum = 0;
    for (my $j=0; $j<=40; $j++) {
      if (defined $stats{$cycle} && defined $stats{$cycle}{$i} && defined $stats{$cycle}{$i}{$j}) {
        $sum += $stats{$cycle}{$i}{$j};
      }
    }
    for (my $j=0; $j<=40; $j++) {
      if (defined $stats{$cycle} && defined $stats{$cycle}{$i} && defined $stats{$cycle}{$i}{$j}) {
        print OUTF3 "\t" . ($stats{$cycle}{$i}{$j} / $sum);
      }
      else {
        print OUTF3 "\t0";
      }
    }
    print OUTF3 "\n";
  }
}
close OUTF3;
}

# Print results using format 2 (table) for not-PF reads
{
open OUTF2, ">$PARAMS{output}.notPF.format2" or die "Can't open $PARAMS{output}.notPF.format2 for writing";
print OUTF2 "# cycle\tlastQ\tcount of newQ=0\tcount of newQ=1\t...\tcount of newQ=40\n";
for (my $cycle=1; $cycle<=$cycleCount; $cycle++) {
  for (my $i=0; $i<=40; $i++) {
    print OUTF2 "$cycle\t$i";
    for (my $j=0; $j<=40; $j++) {
      if (defined $statsNotPF{$cycle} && defined $statsNotPF{$cycle}{$i} && defined $statsNotPF{$cycle}{$i}{$j}) {
        print OUTF2 "\t" . $statsNotPF{$cycle}{$i}{$j};
      }
      else {
        print OUTF2 "\t0";
      }
    }
    print OUTF2 "\n";
  }
}
close OUTF2;
}

print "Done. If you wish to split a format2 table, use an awk script such as awk 'BEGIN { OFS=\"\\t\" } { if (\$1 > 101) { \$1-=101; print \$0 } }'\n";

