/**
 ** Copyright (c) 2014 Illumina, Inc.
 **
 ** This file is part of Illumina's Enhanced Artificial Genome Engine (EAGLE),
 ** covered by the "BSD 2-Clause License" (see accompanying LICENSE file)
 **
 ** \description implements bgzf filtering stream by buffering the compressed data and
 ** rewriting gzip header generated by boost::iostreams::gzip_compressor.
 **
 ** \author Roman Petrovski
 **/

#ifndef EAGLE_BAM_BGZF_COMPRESSOR_HH
#define EAGLE_BAM_BGZF_COMPRESSOR_HH

#include <vector>
#include <boost/iostreams/filtering_stream.hpp>
#include <boost/iostreams/filter/gzip.hpp>

namespace eagle
{
namespace io
{
namespace bam
{

namespace bios=boost::iostreams;

class BgzfCompressor
{
public:
    typedef char char_type;
    struct category : bios::multichar_output_filter_tag , bios::flushable_tag {};
public:
    BgzfCompressor(const bios::gzip_params& = bios::gzip::default_compression);
    BgzfCompressor(const BgzfCompressor& that);

    template <typename Sink>
    std::streamsize write(Sink &snk, const char* s, std::streamsize n);

    void close();

    template<typename Sink>
    bool flush(Sink& snk);

private:
    void initBuffer();
    void rewriteHeader();

    struct BAM_XFIELD
    {
        unsigned char XLEN[2];

        unsigned char SI1;
        unsigned char SI2;
        unsigned char SLEN[2];
        unsigned char BSIZE[2];
    } __attribute__ ((packed));
    BOOST_STATIC_ASSERT(8 == sizeof(BAM_XFIELD));

    struct Header
    {
        unsigned char ID1;
        unsigned char ID2;
        unsigned char CM;
        unsigned char FLG;
        unsigned char MTIME[4];
        unsigned char XFL;
        unsigned char OS;

        BAM_XFIELD xfield;
    } __attribute__ ((packed));
    BOOST_STATIC_ASSERT(18 == sizeof(Header));

    BAM_XFIELD makeBamXfield()
    {
        unsigned short bsize(bgzf_buffer.size()-1);
        BAM_XFIELD ret =
        {
         {(sizeof(BAM_XFIELD) - sizeof(short)) & 0xff, (sizeof(BAM_XFIELD) - sizeof(short)) >> 8},
         66, 67, {2,0}, {static_cast<unsigned char>(bsize & 0xff), static_cast<unsigned char>(bsize >> 8)}
        };
        return ret;
    }
    static const unsigned short max_uncompressed_per_block_ = 0xFFFF;
    const bios::gzip_params gzip_params_;

    std::vector<char> bgzf_buffer;
    boost::iostreams::gzip_compressor compressor_;

    // as it is difficult to predict the size of compressed data, the buffering is based on
    // the amount of uncompressed data consumed. The assumption is that compressed data
    // will always require no more space than the uncompressed.
    size_t uncompressed_in_;
};

template <typename Sink>
std::streamsize BgzfCompressor::write(Sink &snk, const char* s, std::streamsize src_size)
{
    size_t buffer_left(max_uncompressed_per_block_ - uncompressed_in_);
    std::streamsize to_buffer(std::min<std::streamsize>(buffer_left, src_size));

//    std::clog << "will buffer: " << to_buffer << " out of " << src_size << " bytes\n";

    if (to_buffer)
    {
        bios::back_insert_device<std::vector<char> > compressorSnk(bgzf_buffer);
        compressor_.write(compressorSnk, s, to_buffer);
        uncompressed_in_ += to_buffer;
    }

    if (src_size != to_buffer)
    {
        flush(snk);
        write(snk, s + to_buffer, src_size - to_buffer);
    }

    return src_size;
}

template<typename Sink>
bool BgzfCompressor::flush(Sink& snk)
{
    if (uncompressed_in_)
    {
        bios::back_insert_device<std::vector<char> > compressorSnk(bgzf_buffer);
        compressor_.close(compressorSnk, BOOST_IOS::out);
        rewriteHeader();

        bios::write(snk, &bgzf_buffer.front(), bgzf_buffer.size());

        initBuffer();
    }
    return true;
}



} // namespace bam
} // namespace io
} // namespace eagle


#endif // EAGLE_IO_BGZF_COMPRESSOR_HH
